// CProblem.cpp: implementation of the CProblem class.
//
//////////////////////////////////////////////////////////////////////

#include "CProblem.h"

#include <string.h>

extern string ToLower(string);

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CProblem::CProblem()
: dom(NULL)
, static_graph(NULL)
{
	this->plan=NULL;
}

CProblem::~CProblem()
{
	if (this->plan!=NULL) {
	//	delete this->plan;
	}
}

list<string>*	CProblem::GetState(bool init){
	list<string> *ret=new list<string>();
	string s;
	int i,n;

	if (init) n=this->init->Count(); else n=this->goal->Count();
	for(i=0;i<n;i++){
		if (init) s="init("; else s="goal(";
		s+=this->name;
		s+=",";
		if (init)	s+=(*this->init)[i]->GetPrologRepresentationVars(); else s+=(*this->goal)[i]->GetPrologRepresentationVars();
		s+=").";
		ret->push_back(s);
	}

	return ret;
}

void CProblem::SetName(string nm)
{	
	this->name=ToLower(nm);
}

string CProblem::GetName()
{
	return this->name;
}

void CProblem::SetObjects(CTypes *pt)
{
	this->objects=pt;
	this->prob_objects=objects->Clone();
}

void CProblem::GeneratePrologFile()
{
	fstream f;
	string fname;
	list<string> *pins;

	fname=this->name;
	fname+=".pl";

	f.open(fname.data(),fstream::out | fstream::trunc);

	//objects
	pins=this->objects->GetPrologRepresentationForObject(this->name);
	//init
	pins->merge(*this->GetState(true));
	//goal
	pins->merge(*this->GetState(false));
	//training plan
	if (this->plan!=NULL) {pins->merge(*this->plan->GetPrologRepresentation(this->name));}
	//storing of the list of instruction into the Prolog file
	while (!pins->empty()){
		f << pins->front() <<endl;
		pins->pop_front();
	}

	f.close();


}

void CProblem::SetInit(CPredicateList *ppl)
{
	this->init=ppl;
}

void CProblem::SetGoal(CPredicateList *ppl)
{
	this->goal=ppl;
}

void CProblem::AssignPlan(CPlan *p)
{
	this->plan=p;
}

void CProblem::SetOrigFileName(string s)
{
	this->origfilename=s;
}

string CProblem::GetOrigFileName()
{
	return this->origfilename;
}

CPredicateList* CProblem::GetInit()
{
	return this->init;
}

CPredicateList* CProblem::GetGoal()
{
	return this->goal;
}

CPlan* CProblem::GetPlan()
{
	return this->plan;
}

void CProblem::ProblemToPDDL(ostream& s, string dom_name)
{
	s << "; Generated by PTT" << endl;

	s << "(define (problem " << name << ")" << "(:domain " << dom_name << ")" <<endl;

	s << "(:objects " << prob_objects->ToString() << ")" << endl;

	s << "(:init " << init->ToString(false) << (dom->GetActionCost() ? "(= (total-cost) 0)" : "") << ")" << endl;

	s << "(:goal (and  " << goal->ToString(false) << "))" << endl;

	if (dom->GetActionCost()) s << "(:metric minimize (total-cost))" << endl;
	
	s << ")";
}

//must be executed after objects, init and goal are set
void CProblem::AssignTypes(void)
{
	int i;

	for (i=0;i<init->Count();i++){
		(*init)[i]->GetPars()->AssignTypes(objects);
		predcounts_init[(*init)[i]->ToStringSpc()]++;
	}

	for (i=0;i<goal->Count();i++){
		(*goal)[i]->GetPars()->AssignTypes(objects);
		predcounts_goal[(*goal)[i]->ToStringSpc()]++;
	}
}

void CProblem::ReformulateByEntangelments(CPredicateList* ent_init, CPredicateList* ent_goal,CTypes *types)
{
	int i,j,n;
	string s;
	CPredicate *tmp;

	s="stai_";
	n = init->Count();
	for (i=0;i<n;i++){
		for (j=0;j<ent_init->Count();j++){
			if ((*init)[i]->InstanceOf((*ent_init)[j],types)) {
				tmp = (*init)[i]->Clone();
				(*init)[i]->SetEntanglement(true);
				tmp->SetName(s+tmp->GetName());
				init->AddRecord(tmp);
				break;
			}
		}
	}

	s="stag_";
	n = goal->Count();
	for (i=0;i<n;i++){
		for (j=0;j<ent_goal->Count();j++){
			if ((*goal)[i]->InstanceOf((*ent_goal)[j],types)) {
				tmp = (*goal)[i]->Clone();
				(*goal)[i]->SetEntanglement(true);
				tmp->SetName(s+tmp->GetName());
				init->AddRecord(tmp);
				break;
			}
		}
	}
}

void CProblem::ReformulateByInnerEntanglements(CPredicateList* ent_succ, CTypes *types)
{
	for (int i=0;i<ent_succ->Count();i++){
		CPredicateList *pl = (*ent_succ)[i]->MakeAllInstances(objects,types);
		(*init) = (*init) + (*pl); 
		(*goal) = (*goal) + (*pl); 
	}
}

void CProblem::AssignDomain(CDomain* domain)
{
	this->dom=domain;
	if (dom->GetConstannts()!=NULL){
	 objects->Merge(dom->GetConstannts()); 
	  
	}
}

void CProblem::BuildStaticGraph(void)
{
	
	CPredicateList* ent_init = new CPredicateList();
	CPredicateList* ent_goal = new CPredicateList();
	CPredicateList* stat = new CPredicateList();
	CPredicateList *tmplist;

	CActionList *acts = this->dom->GetActions();
	
	if (static_graph!=NULL) delete static_graph;

	AssignTypes();
	
	for (int i=0;i<acts->Count();i++){
		//ent_init+static
		tmplist = (*acts)[i]->GetPrec();
		for (int j=0;j<tmplist->Count();j++){
			if ((*tmplist)[j]->IsEntangled()){
				if (!ent_init->Subsume((*tmplist)[j], this->dom->GetTypes())){
					ent_init->AddRecord((*tmplist)[j]->Clone());
				}
			}
			if ((*tmplist)[j]->IsStatic()){
				if (!stat->Subsume((*tmplist)[j], this->dom->GetTypes())){
					stat->AddRecord((*tmplist)[j]->Clone());
				}
			}
		}
		//ent_goal
		tmplist = (*acts)[i]->GetPosEff();
		for (int j=0;j<tmplist->Count();j++){
			if ((*tmplist)[j]->IsEntangled()){
				if (!ent_goal->Subsume((*tmplist)[j], this->dom->GetTypes())){
					ent_goal->AddRecord((*tmplist)[j]->Clone());
				}
			}
		}
	}

	for (int i=0;i<init->Count();i++){
		for (int j=0;j<ent_init->Count();j++){
			if ((*init)[i]->InstanceOf((*ent_init)[j],this->dom->GetTypes())) {
				(*init)[i]->SetEntanglement(true);
				for (int xx=0;xx<(*init)[i]->GetPars()->Count();xx++){
					string tt = (*(*(*init)[i]->GetPars())[xx]->plisttypes)[0];
					if (types_to_predicate_map.find(tt)==types_to_predicate_map.end()) types_to_predicate_map[tt]=new CPredicateList();
					if (!types_to_predicate_map[tt]->Subsume((*ent_init)[j],this->dom->GetTypes())) types_to_predicate_map[tt]->AddRecord((*ent_init)[j]->Clone());
				}
				break;
			}
		}
		for (int j=0;j<stat->Count();j++){
			if ((*init)[i]->InstanceOf((*stat)[j],this->dom->GetTypes())) {
				(*init)[i]->SetStatic(true);
				for (int xx=0;xx<(*init)[i]->GetPars()->Count();xx++){
					string tt = (*(*(*init)[i]->GetPars())[xx]->plisttypes)[0];
					if (types_to_predicate_map.find(tt)==types_to_predicate_map.end()) types_to_predicate_map[tt]=new CPredicateList();
					if (!types_to_predicate_map[tt]->Subsume((*stat)[j],this->dom->GetTypes())) types_to_predicate_map[tt]->AddRecord((*stat)[j]->Clone());
				}
				break;
			}
		}
	}
	for (int i=0;i<goal->Count();i++){
		for (int j=0;j<ent_goal->Count();j++){
			if ((*goal)[i]->InstanceOf((*ent_goal)[j],this->dom->GetTypes())) {
				(*goal)[i]->SetEntanglement(true);
				for (int xx=0;xx<(*goal)[i]->GetPars()->Count();xx++){
					string tt = (*(*(*goal)[i]->GetPars())[xx]->plisttypes)[0];
					if (types_to_predicate_map.find(tt)==types_to_predicate_map.end()) types_to_predicate_map[tt]=new CPredicateList();
					if (!types_to_predicate_map[tt]->Subsume((*ent_goal)[j],this->dom->GetTypes())) types_to_predicate_map[tt]->AddRecord((*ent_goal)[j]->Clone());
				}
				break;
			}
		}
	}

	deque<TypesRecord>::iterator it;
	int k=0;
	int l=0;

	for(it=objects->GetTypes()->begin();it!=objects->GetTypes()->end();it++){
		deque<string>::iterator it2;
		for (it2=it->plistchilds->begin();it2!=it->plistchilds->end();it2++) {objmap[*it2]=k;k++;obj_type_map[*it2]=it->parent;}
		basicTypes.insert(pair<string,int>(it->parent,it->plistchilds->size()));
	}

	int n=k;
	static_graph=new CPredicate[n*n];
	memset(static_graph,0,n*n*sizeof(CPredicate*));

	for (int i=0;i<init->Count()+goal->Count();i++){
		CPredicate *tmp = i < init->Count() ? (*init)[i] : (*goal)[i-init->Count()];
		if (!tmp->IsStatic()&&!tmp->IsEntangled()) continue;
		for(k=0;k<tmp->GetPars()->Count();k++)
			for(l=0;l<tmp->GetPars()->Count();l++){
				if (k==l) continue;
				*(static_graph+n*objmap[(*tmp->GetPars())[k]->constant]+objmap[(*tmp->GetPars())[l]->constant])=*tmp;
				*(static_graph+n*objmap[(*tmp->GetPars())[l]->constant]+objmap[(*tmp->GetPars())[k]->constant])=*tmp;
			}
	}
	delete ent_init;
	delete ent_goal;
	delete stat;
}

#define cpy(src_it1,src_it2,dest) for(deque<ComponentType>::iterator src_it=src_it1;src_it!=src_it2;src_it++){dest.push_back(*src_it);}

void CProblem::BuildAbstractComponents(void)
{
	deque<ComponentType> groundComp, groundComp_cpy;
	deque<TypesRecord>::iterator it;
	deque<ComponentType>::iterator it1;
	string t;
	deque<string> open;
	set<string> close,types_to_open;
	set<string> tried_preds;
	int n=objmap.size();
	int component_no=0;

	while (!basicTypes.empty()){
		t=(*(basicTypes.begin())).first;
		basicTypes.erase(basicTypes.begin());
		groundComp.clear();
		open.push_back(t);
		//initialize grounded ACs
		for(it=objects->GetTypes()->begin();it!=objects->GetTypes()->end();it++){
			if (t==it->parent) {
				deque<string>::iterator it2;
				for(it2=it->plistchilds->begin();it2!=it->plistchilds->end();it2++){
					ComponentType *ct=new ComponentType();
					ct->consts.insert(*it2);
					//ct->preds=new CPredicateList();
					groundComp.push_back(*ct);
				}
				break;
			}
		}
		AC.push_back(*(new ComponentType()));
		while(!open.empty()){
			t=open.front();
			open.pop_front();
			close.insert(t);
			types_to_open.clear();
			if (types_to_predicate_map.find(t)==types_to_predicate_map.end()) continue;
			for (int i=0;i<types_to_predicate_map[t]->Count();i++){
				CPredicate *p=(*types_to_predicate_map[t])[i];
				if (tried_preds.find(p->ToString(true))!=tried_preds.end()) continue;
				tried_preds.insert(p->ToString(true));
				groundComp_cpy=groundComp;
				//groundComp_cpy.resize(groundComp.size());
//				copy(groundComp.begin(),groundComp.end(),groundComp_cpy.begin());
//				groundComp_cpy.clear();
//				cpy(groundComp.begin(),groundComp.end(),groundComp_cpy);
				set<string> visited;
				bool fail=false;
				for (it1=groundComp.begin();it1!=groundComp.end();it1++){
					set<string>::iterator it3;
					for (it3=it1->consts.begin();it3!=it1->consts.end();it3++){
						if (obj_type_map[*it3]!=t) continue;
						for (int j=0;j<n;j++){
							if ((static_graph+n*objmap[*it3]+j)==NULL) continue;
							CPredicate *tmp = (static_graph+n*objmap[*it3]+j);
							if (!tmp->InstanceOf(p,dom->GetTypes())) continue;
							for (int k=0;k<tmp->GetPars()->Count();k++){
								if (it1->consts.find((*tmp->GetPars())[k]->constant)!=it1->consts.end()) continue;
								if (visited.find((*tmp->GetPars())[k]->constant)!=visited.end()){ //connect components check failed
									fail=true;
									groundComp=groundComp_cpy;
									//groundComp.clear();
									//cpy(groundComp_cpy.begin(),groundComp_cpy.end(),groundComp);
									break;
								} else { 
									it1->consts.insert((*tmp->GetPars())[k]->constant);
									visited.insert((*tmp->GetPars())[k]->constant);
									string t1=(*(*tmp->GetPars())[k]->plisttypes)[0];
									if (find(open.begin(),open.end(),t1)==open.end() && find(close.begin(),close.end(),t1)==close.end()) types_to_open.insert(t1);
									
								}
							}
							if (fail) break;
						}
						if (fail) break;
					}
					if (fail) break;
				}
				if (!fail) {//predicate will be considered for a component
					open.insert(open.end(),types_to_open.begin(),types_to_open.end());
					ComponentType *cur=&AC.back();
					cur->consts.insert(t);
					cur->preds->AddRecord(p->Clone());
					component_no++;
				}

			}
			
		}

	}
}

// debug reasons
void CProblem::OutputAC(ostream& s)
{
	list<ComponentType>::iterator it;
	set<string>::iterator it2;
	deque<CPredicate*>::iterator it3;

	for(it=AC.begin();it!=AC.end();it++){
		s<< "types: ";
		for(it2=it->consts.begin();it2!=it->consts.end();it2++) s << (*it2) << ", ";
		s << endl;
		s<< "predicates: ";
		for(int i=0;i<it->preds->Count();i++) s << (*it->preds)[i]->ToString(true) << ", ";
		s << endl;
	}
}

list<ComponentType> CProblem::globalAC;
// after building ACs for every training problem
void CProblem::GetGlobalAC(deque<CProblem*>* training)
{
	deque<CProblem*>::iterator it;
	list<ComponentType>::iterator it2,it3;
	bool erase;
	if (training->size()==0) return; // no training problem
	globalAC=(*training->begin())->AC;
	for(it=training->begin()+1;it!=training->end();it++){
		for(it2=globalAC.begin();it2!=globalAC.end();!erase ? it2++ : it2){
			erase=false;
			if (it2->preds->Count()==0){it2=globalAC.erase(it2);erase=true;continue;}
			for(it3=(*it)->AC.begin();it3!=(*it)->AC.end();it3++){
				CPredicateList *tmppl = &((*it2->preds) * (*it3->preds));
				if (tmppl->Count()==0) continue;
				if (tmppl->Count()==it2->preds->Count()) break;
				//globalAC.erase(it2);
				erase=true;
				ComponentType *ct=new ComponentType();
				ct->preds=tmppl;
				globalAC.push_back(*ct);
			}	
			if (erase) it2=globalAC.erase(it2);
		}
	}
}

bool CProblem::CheckLocalityRule(CAction* a,CTypes *types)
{
	int ACused=-1;
	int k;

	CPredicateList *tmppl;
	list<ComponentType>::iterator it;

	//precondition
	tmppl=a->GetPrec();
	for(int i=0;i<tmppl->Count();i++){
		if ((*tmppl)[i]->IsEntangled() || (*tmppl)[i]->IsStatic()){
			//go through the AC list
			k=0;
			for (it=globalAC.begin();it!=globalAC.end();it++){
				if (it->preds->Subsume((*tmppl)[i],types)){
					if (ACused!=-1 && ACused!=k) return false; //we have more components...
					ACused=k;break;
				}
				k++;
			}
		}
	}
	ACused=-1;
	//positive effects
	tmppl=a->GetPosEff();
	for(int i=0;i<tmppl->Count();i++){
		if ((*tmppl)[i]->IsEntangled()){
			//go through the AC list
			k=0;
			for (it=globalAC.begin();it!=globalAC.end();it++){
				if (it->preds->Subsume((*tmppl)[i],types)){
					if (ACused!=-1 && ACused!=k) return false; //we have more components...
					ACused=k;break;
				}
				k++;
			}
		}
	}

	return true;
}

void CProblem::DetermineAllInstancesPredicates()
{
  CPredicateList* preds=dom->GetPredicates();
  
  //init
  for (int i=0;i<init->Count();i++) predcounts_init[(*init)[i]->GetName()]++;
  //goal
  for (int i=0;i<goal->Count();i++) predcounts_goal[(*goal)[i]->GetName()]++;
  
  
  for (int j=0;j<preds->Count();j++){
     int cnt=1;
     if ((*preds)[j]->GetPars() != NULL){
       for (int k=0;k<(*preds)[j]->GetPars()->Count();k++){
	 if (cnt > predcounts_init[(*preds)[j]->GetName()] && cnt > predcounts_goal[(*preds)[j]->GetName()]) break;
	 cnt *= dom->GetTypes()->FindAllObjects((*(*preds)[j]->GetPars())[k]->plisttypes,objects)->size(); 
       }
     } 
     if (cnt == predcounts_init[(*preds)[j]->GetName()]) allinstpreds_init.push_back((*preds)[j]->GetName());
     if (cnt == predcounts_goal[(*preds)[j]->GetName()]) allinstpreds_goal.push_back((*preds)[j]->GetName());
  }
  
  sort(allinstpreds_init.begin(),allinstpreds_init.end());
  sort(allinstpreds_goal.begin(),allinstpreds_goal.end());
 
}

int CProblem::ObjectsUpperBound(CPredicate* p)
{
  int ret=0;
  if (p->GetPars()==NULL || p->GetPars()->Count()==0) return 1;
  for (int k=0;k<p->GetPars()->Count();k++){
      
      int cnt = dom->GetTypes()->FindAllObjects((*p->GetPars())[k]->plisttypes,objects)->size(); 
      if (cnt > ret) ret=cnt;
  }
  return ret;
  
}


void CProblem::NumberOfPredicatesRec(std::vector< deque< string >* >* t, int arg_no, string part, int* ret, bool init)
{
  int n=t->size();
  if (arg_no>=n){
    (*ret)+=init ? predcounts_init[part] : predcounts_goal[part];
  } else {
    deque<string>::iterator it;
    for (it=(*t)[arg_no]->begin();it!=(*t)[arg_no]->end();it++){
       string tmp=part;
       tmp+=" ";
       tmp+=(*it);
       NumberOfPredicatesRec(t,arg_no+1,tmp,ret,init);
    }
  }
  
}


int CProblem::NumberOfPredicates(CPredicate* p, bool init)
{
   
  if (init) {
    if (predcounts_init.find(p->ToStringSpc())==predcounts_init.end()){
       vector <deque <string>* > types;
       for (int i=0;i<p->GetPars()->Count();i++){
	  deque<string> *out = new deque<string>();
	  this->dom->GetTypes()->FindAllLeafTypes((*p->GetPars())[i]->plisttypes,out);
	  types.push_back(out); 
       }
       int x=0;
       NumberOfPredicatesRec(&types,0,p->GetName(),&x,init);
       predcounts_init[p->ToStringSpc()]=x; 
    } 
      
      return predcounts_init[p->ToStringSpc()]; 
    
    
  } else {
     if (predcounts_goal.find(p->ToStringSpc())==predcounts_goal.end()){
       vector <deque <string>* > types;
       for (int i=0;i<p->GetPars()->Count();i++){
	  deque<string> *out = new deque<string>();
	  this->dom->GetTypes()->FindAllLeafTypes((*p->GetPars())[i]->plisttypes,out);
	  types.push_back(out); 
       }
       int x=0;
       NumberOfPredicatesRec(&types,0,p->GetName(),&x,init);
       predcounts_goal[p->ToStringSpc()]=x; 
    } 
      
      return predcounts_goal[p->ToStringSpc()]; 
    
  }

}

